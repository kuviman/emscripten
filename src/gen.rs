/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl <T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const EM_TIMING_SETTIMEOUT: ::std::os::raw::c_uint = 0;
pub const EM_TIMING_RAF: ::std::os::raw::c_uint = 1;
pub const EM_TIMING_SETIMMEDIATE: ::std::os::raw::c_uint = 2;
pub const EM_LOG_CONSOLE: ::std::os::raw::c_uint = 1;
pub const EM_LOG_WARN: ::std::os::raw::c_uint = 2;
pub const EM_LOG_ERROR: ::std::os::raw::c_uint = 4;
pub const EM_LOG_C_STACK: ::std::os::raw::c_uint = 8;
pub const EM_LOG_JS_STACK: ::std::os::raw::c_uint = 16;
pub const EM_LOG_DEMANGLE: ::std::os::raw::c_uint = 32;
pub const EM_LOG_NO_PATHS: ::std::os::raw::c_uint = 64;
pub const EM_LOG_FUNC_PARAMS: ::std::os::raw::c_uint = 128;
pub const EM_TRUE: ::std::os::raw::c_uint = 1;
pub const EM_FALSE: ::std::os::raw::c_uint = 0;
pub const EM_HTML5_SHORT_STRING_LEN_BYTES: ::std::os::raw::c_uint = 32;
pub const EM_HTML5_MEDIUM_STRING_LEN_BYTES: ::std::os::raw::c_uint = 64;
pub const EM_HTML5_LONG_STRING_LEN_BYTES: ::std::os::raw::c_uint = 128;
pub const EM_QUEUED_CALL_MAX_ARGS: ::std::os::raw::c_uint = 8;
pub const EM_FUNC_SIG_V: ::std::os::raw::c_uint = 1024;
pub const EM_FUNC_SIG_VI: ::std::os::raw::c_uint = 1025;
pub const EM_FUNC_SIG_VII: ::std::os::raw::c_uint = 1026;
pub const EM_FUNC_SIG_VIII: ::std::os::raw::c_uint = 1027;
pub const EM_FUNC_SIG_I: ::std::os::raw::c_uint = 2048;
pub const EM_FUNC_SIG_II: ::std::os::raw::c_uint = 2049;
pub const EM_FUNC_SIG_III: ::std::os::raw::c_uint = 2050;
pub const EM_FUNC_SIG_IIII: ::std::os::raw::c_uint = 2051;
pub const EM_THREAD_STATUS_NOTSTARTED: ::std::os::raw::c_uint = 0;
pub const EM_THREAD_STATUS_RUNNING: ::std::os::raw::c_uint = 1;
pub const EM_THREAD_STATUS_SLEEPING: ::std::os::raw::c_uint = 2;
pub const EM_THREAD_STATUS_WAITFUTEX: ::std::os::raw::c_uint = 3;
pub const EM_THREAD_STATUS_WAITMUTEX: ::std::os::raw::c_uint = 4;
pub const EM_THREAD_STATUS_WAITPROXY: ::std::os::raw::c_uint = 5;
pub const EM_THREAD_STATUS_FINISHED: ::std::os::raw::c_uint = 6;
pub const EM_THREAD_STATUS_NUMFIELDS: ::std::os::raw::c_uint = 7;
pub const EM_PROXIED_UTIME: ::std::os::raw::c_uint = 12;
pub const EM_PROXIED_UTIMES: ::std::os::raw::c_uint = 13;
pub const EM_PROXIED_CHROOT: ::std::os::raw::c_uint = 37;
pub const EM_PROXIED_FPATHCONF: ::std::os::raw::c_uint = 46;
pub const EM_PROXIED_CONFSTR: ::std::os::raw::c_uint = 68;
pub const EM_PROXIED_SYSCONF: ::std::os::raw::c_uint = 72;
pub const EM_PROXIED_ATEXIT: ::std::os::raw::c_uint = 110;
pub const EM_PROXIED_GETENV: ::std::os::raw::c_uint = 111;
pub const EM_PROXIED_CLEARENV: ::std::os::raw::c_uint = 112;
pub const EM_PROXIED_SETENV: ::std::os::raw::c_uint = 113;
pub const EM_PROXIED_UNSETENV: ::std::os::raw::c_uint = 114;
pub const EM_PROXIED_PUTENV: ::std::os::raw::c_uint = 115;
pub const EM_PROXIED_TZSET: ::std::os::raw::c_uint = 119;
pub const EM_PROXIED_PTHREAD_CREATE: ::std::os::raw::c_uint = 137;
pub const EM_PROXIED_SYSCALL: ::std::os::raw::c_uint = 138;
extern "C" {
    #[link_name = "_Z20emscripten_asm_constPKc"]
    pub fn emscripten_asm_const(code: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type emscripten_align1_short = ::std::os::raw::c_short;
pub type emscripten_align4_int64 = ::std::os::raw::c_longlong;
pub type emscripten_align2_int64 = ::std::os::raw::c_longlong;
pub type emscripten_align1_int64 = ::std::os::raw::c_longlong;
pub type emscripten_align2_int = ::std::os::raw::c_int;
pub type emscripten_align1_int = ::std::os::raw::c_int;
pub type emscripten_align2_float = f32;
pub type emscripten_align1_float = f32;
pub type emscripten_align4_double = f64;
pub type emscripten_align2_double = f64;
pub type emscripten_align1_double = f64;
pub type em_callback_func = ::core::option::Option<unsafe extern "C" fn()>;
pub type em_arg_callback_func =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void)>;
pub type em_str_callback_func =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn emscripten_run_script(script: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn emscripten_run_script_int(script: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_run_script_string(script: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn emscripten_async_run_script(script: *const ::std::os::raw::c_char,
                                       millis: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_async_load_script(script: *const ::std::os::raw::c_char,
                                        onload: em_callback_func,
                                        onerror: em_callback_func);
}
extern "C" {
    pub fn emscripten_set_main_loop(func: em_callback_func,
                                    fps: ::std::os::raw::c_int,
                                    simulate_infinite_loop:
                                        ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_set_main_loop_timing(mode: ::std::os::raw::c_int,
                                           value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_main_loop_timing(mode: *mut ::std::os::raw::c_int,
                                           value: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_set_main_loop_arg(func: em_arg_callback_func,
                                        arg: *mut ::std::os::raw::c_void,
                                        fps: ::std::os::raw::c_int,
                                        simulate_infinite_loop:
                                            ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_pause_main_loop();
}
extern "C" {
    pub fn emscripten_resume_main_loop();
}
extern "C" {
    pub fn emscripten_cancel_main_loop();
}
pub type em_socket_callback =
    ::core::option::Option<unsafe extern "C" fn(fd: ::std::os::raw::c_int,
                                                userData:
                                                    *mut ::std::os::raw::c_void)>;
pub type em_socket_error_callback =
    ::core::option::Option<unsafe extern "C" fn(fd: ::std::os::raw::c_int,
                                                err: ::std::os::raw::c_int,
                                                msg:
                                                    *const ::std::os::raw::c_char,
                                                userData:
                                                    *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn emscripten_set_socket_error_callback(userData:
                                                    *mut ::std::os::raw::c_void,
                                                callback:
                                                    em_socket_error_callback);
}
extern "C" {
    pub fn emscripten_set_socket_open_callback(userData:
                                                   *mut ::std::os::raw::c_void,
                                               callback: em_socket_callback);
}
extern "C" {
    pub fn emscripten_set_socket_listen_callback(userData:
                                                     *mut ::std::os::raw::c_void,
                                                 callback:
                                                     em_socket_callback);
}
extern "C" {
    pub fn emscripten_set_socket_connection_callback(userData:
                                                         *mut ::std::os::raw::c_void,
                                                     callback:
                                                         em_socket_callback);
}
extern "C" {
    pub fn emscripten_set_socket_message_callback(userData:
                                                      *mut ::std::os::raw::c_void,
                                                  callback:
                                                      em_socket_callback);
}
extern "C" {
    pub fn emscripten_set_socket_close_callback(userData:
                                                    *mut ::std::os::raw::c_void,
                                                callback: em_socket_callback);
}
extern "C" {
    pub fn _emscripten_push_main_loop_blocker(func: em_arg_callback_func,
                                              arg:
                                                  *mut ::std::os::raw::c_void,
                                              name:
                                                  *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _emscripten_push_uncounted_main_loop_blocker(func:
                                                            em_arg_callback_func,
                                                        arg:
                                                            *mut ::std::os::raw::c_void,
                                                        name:
                                                            *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn emscripten_set_main_loop_expected_blockers(num:
                                                          ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_async_call(func: em_arg_callback_func,
                                 arg: *mut ::std::os::raw::c_void,
                                 millis: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_exit_with_live_runtime();
}
extern "C" {
    pub fn emscripten_force_exit(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_get_device_pixel_ratio() -> f64;
}
extern "C" {
    pub fn emscripten_hide_mouse();
}
extern "C" {
    pub fn emscripten_set_canvas_size(width: ::std::os::raw::c_int,
                                      height: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_get_canvas_size(width: *mut ::std::os::raw::c_int,
                                      height: *mut ::std::os::raw::c_int,
                                      isFullscreen:
                                          *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_get_now() -> f64;
}
extern "C" {
    pub fn emscripten_random() -> f32;
}
extern "C" {
    pub fn emscripten_async_wget(url: *const ::std::os::raw::c_char,
                                 file: *const ::std::os::raw::c_char,
                                 onload: em_str_callback_func,
                                 onerror: em_str_callback_func);
}
pub type em_async_wget_onload_func =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3: ::std::os::raw::c_int)>;
extern "C" {
    pub fn emscripten_async_wget_data(url: *const ::std::os::raw::c_char,
                                      arg: *mut ::std::os::raw::c_void,
                                      onload: em_async_wget_onload_func,
                                      onerror: em_arg_callback_func);
}
pub type em_async_wget2_onload_func =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3:
                                                    *const ::std::os::raw::c_char)>;
pub type em_async_wget2_onstatus_func =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3: ::std::os::raw::c_int)>;
extern "C" {
    pub fn emscripten_async_wget2(url: *const ::std::os::raw::c_char,
                                  file: *const ::std::os::raw::c_char,
                                  requesttype: *const ::std::os::raw::c_char,
                                  param: *const ::std::os::raw::c_char,
                                  arg: *mut ::std::os::raw::c_void,
                                  onload: em_async_wget2_onload_func,
                                  onerror: em_async_wget2_onstatus_func,
                                  onprogress: em_async_wget2_onstatus_func)
     -> ::std::os::raw::c_int;
}
pub type em_async_wget2_data_onload_func =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3:
                                                    *mut ::std::os::raw::c_void,
                                                arg4:
                                                    ::std::os::raw::c_uint)>;
pub type em_async_wget2_data_onerror_func =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3: ::std::os::raw::c_int,
                                                arg4:
                                                    *const ::std::os::raw::c_char)>;
pub type em_async_wget2_data_onprogress_func =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3: ::std::os::raw::c_int,
                                                arg4: ::std::os::raw::c_int)>;
extern "C" {
    pub fn emscripten_async_wget2_data(url: *const ::std::os::raw::c_char,
                                       requesttype:
                                           *const ::std::os::raw::c_char,
                                       param: *const ::std::os::raw::c_char,
                                       arg: *mut ::std::os::raw::c_void,
                                       free: ::std::os::raw::c_int,
                                       onload:
                                           em_async_wget2_data_onload_func,
                                       onerror:
                                           em_async_wget2_data_onerror_func,
                                       onprogress:
                                           em_async_wget2_data_onprogress_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_async_wget2_abort(handle: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_wget(url: *const ::std::os::raw::c_char,
                           file: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn emscripten_wget_data(url: *const ::std::os::raw::c_char,
                                pbuffer: *mut *mut ::std::os::raw::c_void,
                                pnum: *mut ::std::os::raw::c_int,
                                perror: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_idb_async_load(db_name: *const ::std::os::raw::c_char,
                                     file_id: *const ::std::os::raw::c_char,
                                     arg: *mut ::std::os::raw::c_void,
                                     onload: em_async_wget_onload_func,
                                     onerror: em_arg_callback_func);
}
extern "C" {
    pub fn emscripten_idb_async_store(db_name: *const ::std::os::raw::c_char,
                                      file_id: *const ::std::os::raw::c_char,
                                      ptr: *mut ::std::os::raw::c_void,
                                      num: ::std::os::raw::c_int,
                                      arg: *mut ::std::os::raw::c_void,
                                      onstore: em_arg_callback_func,
                                      onerror: em_arg_callback_func);
}
extern "C" {
    pub fn emscripten_idb_async_delete(db_name: *const ::std::os::raw::c_char,
                                       file_id: *const ::std::os::raw::c_char,
                                       arg: *mut ::std::os::raw::c_void,
                                       ondelete: em_arg_callback_func,
                                       onerror: em_arg_callback_func);
}
pub type em_idb_exists_func =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: ::std::os::raw::c_int)>;
extern "C" {
    pub fn emscripten_idb_async_exists(db_name: *const ::std::os::raw::c_char,
                                       file_id: *const ::std::os::raw::c_char,
                                       arg: *mut ::std::os::raw::c_void,
                                       oncheck: em_idb_exists_func,
                                       onerror: em_arg_callback_func);
}
extern "C" {
    pub fn emscripten_idb_load(db_name: *const ::std::os::raw::c_char,
                               file_id: *const ::std::os::raw::c_char,
                               pbuffer: *mut *mut ::std::os::raw::c_void,
                               pnum: *mut ::std::os::raw::c_int,
                               perror: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_idb_store(db_name: *const ::std::os::raw::c_char,
                                file_id: *const ::std::os::raw::c_char,
                                buffer: *mut ::std::os::raw::c_void,
                                num: ::std::os::raw::c_int,
                                perror: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_idb_delete(db_name: *const ::std::os::raw::c_char,
                                 file_id: *const ::std::os::raw::c_char,
                                 perror: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_idb_exists(db_name: *const ::std::os::raw::c_char,
                                 file_id: *const ::std::os::raw::c_char,
                                 pexists: *mut ::std::os::raw::c_int,
                                 perror: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_idb_load_blob(db_name: *const ::std::os::raw::c_char,
                                    file_id: *const ::std::os::raw::c_char,
                                    pblob: *mut ::std::os::raw::c_int,
                                    perror: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_idb_store_blob(db_name: *const ::std::os::raw::c_char,
                                     file_id: *const ::std::os::raw::c_char,
                                     buffer: *mut ::std::os::raw::c_void,
                                     num: ::std::os::raw::c_int,
                                     perror: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_idb_read_from_blob(blob: ::std::os::raw::c_int,
                                         start: ::std::os::raw::c_int,
                                         num: ::std::os::raw::c_int,
                                         buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn emscripten_idb_free_blob(blob: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_run_preload_plugins(file: *const ::std::os::raw::c_char,
                                          onload: em_str_callback_func,
                                          onerror: em_str_callback_func)
     -> ::std::os::raw::c_int;
}
pub type em_run_preload_plugins_data_onload_func =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2:
                                                    *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn emscripten_run_preload_plugins_data(data:
                                                   *mut ::std::os::raw::c_char,
                                               size: ::std::os::raw::c_int,
                                               suffix:
                                                   *const ::std::os::raw::c_char,
                                               arg:
                                                   *mut ::std::os::raw::c_void,
                                               onload:
                                                   em_run_preload_plugins_data_onload_func,
                                               onerror: em_arg_callback_func);
}
pub type worker_handle = ::std::os::raw::c_int;
extern "C" {
    pub fn emscripten_create_worker(url: *const ::std::os::raw::c_char)
     -> worker_handle;
}
extern "C" {
    pub fn emscripten_destroy_worker(worker: worker_handle);
}
pub type em_worker_callback_func =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_char,
                                                arg2: ::std::os::raw::c_int,
                                                arg3:
                                                    *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn emscripten_call_worker(worker: worker_handle,
                                  funcname: *const ::std::os::raw::c_char,
                                  data: *mut ::std::os::raw::c_char,
                                  size: ::std::os::raw::c_int,
                                  callback: em_worker_callback_func,
                                  arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn emscripten_worker_respond(data: *mut ::std::os::raw::c_char,
                                     size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_worker_respond_provisionally(data:
                                                       *mut ::std::os::raw::c_char,
                                                   size:
                                                       ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_get_worker_queue_size(worker: worker_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_compiler_setting(name:
                                               *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_debugger();
}
extern "C" {
    pub fn emscripten_get_preloaded_image_data(path:
                                                   *const ::std::os::raw::c_char,
                                               w: *mut ::std::os::raw::c_int,
                                               h: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn emscripten_get_preloaded_image_data_from_FILE(file: *mut FILE,
                                                         w:
                                                             *mut ::std::os::raw::c_int,
                                                         h:
                                                             *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn emscripten_log(flags: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn emscripten_get_callstack(flags: ::std::os::raw::c_int,
                                    out: *mut ::std::os::raw::c_char,
                                    maxbytes: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_print_double(x: f64, to: *mut ::std::os::raw::c_char,
                                   max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_sleep(ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn emscripten_sleep_with_yield(ms: ::std::os::raw::c_uint);
}
pub type emscripten_coroutine = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn emscripten_coroutine_create(func: em_arg_callback_func,
                                       arg: *mut ::std::os::raw::c_void,
                                       stack_size: ::std::os::raw::c_int)
     -> emscripten_coroutine;
}
extern "C" {
    pub fn emscripten_coroutine_next(arg1: emscripten_coroutine)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_yield();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenKeyboardEvent {
    pub key: [::std::os::raw::c_char; 32usize],
    pub code: [::std::os::raw::c_char; 32usize],
    pub location: ::std::os::raw::c_ulong,
    pub ctrlKey: ::std::os::raw::c_int,
    pub shiftKey: ::std::os::raw::c_int,
    pub altKey: ::std::os::raw::c_int,
    pub metaKey: ::std::os::raw::c_int,
    pub repeat: ::std::os::raw::c_int,
    pub locale: [::std::os::raw::c_char; 32usize],
    pub charValue: [::std::os::raw::c_char; 32usize],
    pub charCode: ::std::os::raw::c_ulong,
    pub keyCode: ::std::os::raw::c_ulong,
    pub which: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_EmscriptenKeyboardEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenKeyboardEvent>() , 184usize ,
               concat ! (
               "Size of: " , stringify ! ( EmscriptenKeyboardEvent ) ));
    assert_eq! (::core::mem::align_of::<EmscriptenKeyboardEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenKeyboardEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . key as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . code as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . location as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . ctrlKey as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( ctrlKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . shiftKey as
                * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( shiftKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . altKey as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( altKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . metaKey as
                * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( metaKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . repeat as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( repeat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . locale as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( locale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . charValue
                as * const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( charValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . charCode as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( charCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . keyCode as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( keyCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenKeyboardEvent ) ) . which as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenKeyboardEvent
                ) , "::" , stringify ! ( which ) ));
}
impl Clone for EmscriptenKeyboardEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_key_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                keyEvent:
                                                    *const EmscriptenKeyboardEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_keypress_callback(target:
                                                *const ::std::os::raw::c_char,
                                            userData:
                                                *mut ::std::os::raw::c_void,
                                            useCapture: ::std::os::raw::c_int,
                                            callback: em_key_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_keydown_callback(target:
                                               *const ::std::os::raw::c_char,
                                           userData:
                                               *mut ::std::os::raw::c_void,
                                           useCapture: ::std::os::raw::c_int,
                                           callback: em_key_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_keyup_callback(target:
                                             *const ::std::os::raw::c_char,
                                         userData:
                                             *mut ::std::os::raw::c_void,
                                         useCapture: ::std::os::raw::c_int,
                                         callback: em_key_callback_func)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenMouseEvent {
    pub timestamp: f64,
    pub screenX: ::std::os::raw::c_long,
    pub screenY: ::std::os::raw::c_long,
    pub clientX: ::std::os::raw::c_long,
    pub clientY: ::std::os::raw::c_long,
    pub ctrlKey: ::std::os::raw::c_int,
    pub shiftKey: ::std::os::raw::c_int,
    pub altKey: ::std::os::raw::c_int,
    pub metaKey: ::std::os::raw::c_int,
    pub button: ::std::os::raw::c_ushort,
    pub buttons: ::std::os::raw::c_ushort,
    pub movementX: ::std::os::raw::c_long,
    pub movementY: ::std::os::raw::c_long,
    pub targetX: ::std::os::raw::c_long,
    pub targetY: ::std::os::raw::c_long,
    pub canvasX: ::std::os::raw::c_long,
    pub canvasY: ::std::os::raw::c_long,
    pub padding: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_EmscriptenMouseEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenMouseEvent>() , 120usize ,
               concat ! ( "Size of: " , stringify ! ( EmscriptenMouseEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenMouseEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenMouseEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . timestamp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . screenX as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( screenX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . screenY as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( screenY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . clientX as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( clientX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . clientY as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( clientY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . ctrlKey as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( ctrlKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . shiftKey as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( shiftKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . altKey as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( altKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . metaKey as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( metaKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . button as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . buttons as *
                const _ as usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( buttons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . movementX as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( movementX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . movementY as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( movementY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . targetX as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( targetX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . targetY as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( targetY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . canvasX as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( canvasX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . canvasY as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( canvasY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenMouseEvent ) ) . padding as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenMouseEvent )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for EmscriptenMouseEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_mouse_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                mouseEvent:
                                                    *const EmscriptenMouseEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_click_callback(target:
                                             *const ::std::os::raw::c_char,
                                         userData:
                                             *mut ::std::os::raw::c_void,
                                         useCapture: ::std::os::raw::c_int,
                                         callback: em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_mousedown_callback(target:
                                                 *const ::std::os::raw::c_char,
                                             userData:
                                                 *mut ::std::os::raw::c_void,
                                             useCapture:
                                                 ::std::os::raw::c_int,
                                             callback: em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_mouseup_callback(target:
                                               *const ::std::os::raw::c_char,
                                           userData:
                                               *mut ::std::os::raw::c_void,
                                           useCapture: ::std::os::raw::c_int,
                                           callback: em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_dblclick_callback(target:
                                                *const ::std::os::raw::c_char,
                                            userData:
                                                *mut ::std::os::raw::c_void,
                                            useCapture: ::std::os::raw::c_int,
                                            callback: em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_mousemove_callback(target:
                                                 *const ::std::os::raw::c_char,
                                             userData:
                                                 *mut ::std::os::raw::c_void,
                                             useCapture:
                                                 ::std::os::raw::c_int,
                                             callback: em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_mouseenter_callback(target:
                                                  *const ::std::os::raw::c_char,
                                              userData:
                                                  *mut ::std::os::raw::c_void,
                                              useCapture:
                                                  ::std::os::raw::c_int,
                                              callback:
                                                  em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_mouseleave_callback(target:
                                                  *const ::std::os::raw::c_char,
                                              userData:
                                                  *mut ::std::os::raw::c_void,
                                              useCapture:
                                                  ::std::os::raw::c_int,
                                              callback:
                                                  em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_mouseover_callback(target:
                                                 *const ::std::os::raw::c_char,
                                             userData:
                                                 *mut ::std::os::raw::c_void,
                                             useCapture:
                                                 ::std::os::raw::c_int,
                                             callback: em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_mouseout_callback(target:
                                                *const ::std::os::raw::c_char,
                                            userData:
                                                *mut ::std::os::raw::c_void,
                                            useCapture: ::std::os::raw::c_int,
                                            callback: em_mouse_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_mouse_status(mouseState: *mut EmscriptenMouseEvent)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenWheelEvent {
    pub mouse: EmscriptenMouseEvent,
    pub deltaX: f64,
    pub deltaY: f64,
    pub deltaZ: f64,
    pub deltaMode: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_EmscriptenWheelEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenWheelEvent>() , 152usize ,
               concat ! ( "Size of: " , stringify ! ( EmscriptenWheelEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenWheelEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenWheelEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWheelEvent ) ) . mouse as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenWheelEvent )
                , "::" , stringify ! ( mouse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWheelEvent ) ) . deltaX as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenWheelEvent )
                , "::" , stringify ! ( deltaX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWheelEvent ) ) . deltaY as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenWheelEvent )
                , "::" , stringify ! ( deltaY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWheelEvent ) ) . deltaZ as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenWheelEvent )
                , "::" , stringify ! ( deltaZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWheelEvent ) ) . deltaMode as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenWheelEvent )
                , "::" , stringify ! ( deltaMode ) ));
}
impl Clone for EmscriptenWheelEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_wheel_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                wheelEvent:
                                                    *const EmscriptenWheelEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_wheel_callback(target:
                                             *const ::std::os::raw::c_char,
                                         userData:
                                             *mut ::std::os::raw::c_void,
                                         useCapture: ::std::os::raw::c_int,
                                         callback: em_wheel_callback_func)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenUiEvent {
    pub detail: ::std::os::raw::c_long,
    pub documentBodyClientWidth: ::std::os::raw::c_int,
    pub documentBodyClientHeight: ::std::os::raw::c_int,
    pub windowInnerWidth: ::std::os::raw::c_int,
    pub windowInnerHeight: ::std::os::raw::c_int,
    pub windowOuterWidth: ::std::os::raw::c_int,
    pub windowOuterHeight: ::std::os::raw::c_int,
    pub scrollTop: ::std::os::raw::c_int,
    pub scrollLeft: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EmscriptenUiEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenUiEvent>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( EmscriptenUiEvent ) ));
    assert_eq! (::core::mem::align_of::<EmscriptenUiEvent>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( EmscriptenUiEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) . detail as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( detail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) .
                documentBodyClientWidth as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( documentBodyClientWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) .
                documentBodyClientHeight as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( documentBodyClientHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) . windowInnerWidth
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( windowInnerWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) . windowInnerHeight
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( windowInnerHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) . windowOuterWidth
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( windowOuterWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) . windowOuterHeight
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( windowOuterHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) . scrollTop as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( scrollTop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenUiEvent ) ) . scrollLeft as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenUiEvent ) ,
                "::" , stringify ! ( scrollLeft ) ));
}
impl Clone for EmscriptenUiEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_ui_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                uiEvent:
                                                    *const EmscriptenUiEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_resize_callback(target:
                                              *const ::std::os::raw::c_char,
                                          userData:
                                              *mut ::std::os::raw::c_void,
                                          useCapture: ::std::os::raw::c_int,
                                          callback: em_ui_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_scroll_callback(target:
                                              *const ::std::os::raw::c_char,
                                          userData:
                                              *mut ::std::os::raw::c_void,
                                          useCapture: ::std::os::raw::c_int,
                                          callback: em_ui_callback_func)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct EmscriptenFocusEvent {
    pub nodeName: [::std::os::raw::c_char; 128usize],
    pub id: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_EmscriptenFocusEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenFocusEvent>() , 256usize ,
               concat ! ( "Size of: " , stringify ! ( EmscriptenFocusEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenFocusEvent>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenFocusEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFocusEvent ) ) . nodeName as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenFocusEvent )
                , "::" , stringify ! ( nodeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFocusEvent ) ) . id as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenFocusEvent )
                , "::" , stringify ! ( id ) ));
}
pub type em_focus_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                focusEvent:
                                                    *const EmscriptenFocusEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_blur_callback(target: *const ::std::os::raw::c_char,
                                        userData: *mut ::std::os::raw::c_void,
                                        useCapture: ::std::os::raw::c_int,
                                        callback: em_focus_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_focus_callback(target:
                                             *const ::std::os::raw::c_char,
                                         userData:
                                             *mut ::std::os::raw::c_void,
                                         useCapture: ::std::os::raw::c_int,
                                         callback: em_focus_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_focusin_callback(target:
                                               *const ::std::os::raw::c_char,
                                           userData:
                                               *mut ::std::os::raw::c_void,
                                           useCapture: ::std::os::raw::c_int,
                                           callback: em_focus_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_focusout_callback(target:
                                                *const ::std::os::raw::c_char,
                                            userData:
                                                *mut ::std::os::raw::c_void,
                                            useCapture: ::std::os::raw::c_int,
                                            callback: em_focus_callback_func)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenDeviceOrientationEvent {
    pub timestamp: f64,
    pub alpha: f64,
    pub beta: f64,
    pub gamma: f64,
    pub absolute: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EmscriptenDeviceOrientationEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenDeviceOrientationEvent>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( EmscriptenDeviceOrientationEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenDeviceOrientationEvent>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                EmscriptenDeviceOrientationEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceOrientationEvent ) ) .
                timestamp as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceOrientationEvent ) , "::" , stringify ! (
                timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceOrientationEvent ) ) .
                alpha as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceOrientationEvent ) , "::" , stringify ! (
                alpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceOrientationEvent ) ) .
                beta as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceOrientationEvent ) , "::" , stringify ! ( beta
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceOrientationEvent ) ) .
                gamma as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceOrientationEvent ) , "::" , stringify ! (
                gamma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceOrientationEvent ) ) .
                absolute as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceOrientationEvent ) , "::" , stringify ! (
                absolute ) ));
}
impl Clone for EmscriptenDeviceOrientationEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_deviceorientation_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                deviceOrientationEvent:
                                                    *const EmscriptenDeviceOrientationEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_deviceorientation_callback(userData:
                                                         *mut ::std::os::raw::c_void,
                                                     useCapture:
                                                         ::std::os::raw::c_int,
                                                     callback:
                                                         em_deviceorientation_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_deviceorientation_status(orientationState:
                                                       *mut EmscriptenDeviceOrientationEvent)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenDeviceMotionEvent {
    pub timestamp: f64,
    pub accelerationX: f64,
    pub accelerationY: f64,
    pub accelerationZ: f64,
    pub accelerationIncludingGravityX: f64,
    pub accelerationIncludingGravityY: f64,
    pub accelerationIncludingGravityZ: f64,
    pub rotationRateAlpha: f64,
    pub rotationRateBeta: f64,
    pub rotationRateGamma: f64,
}
#[test]
fn bindgen_test_layout_EmscriptenDeviceMotionEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenDeviceMotionEvent>() , 80usize
               , concat ! (
               "Size of: " , stringify ! ( EmscriptenDeviceMotionEvent ) ));
    assert_eq! (::core::mem::align_of::<EmscriptenDeviceMotionEvent>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( EmscriptenDeviceMotionEvent )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                timestamp as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! ( timestamp
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                accelerationX as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                accelerationX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                accelerationY as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                accelerationY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                accelerationZ as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                accelerationZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                accelerationIncludingGravityX as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                accelerationIncludingGravityX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                accelerationIncludingGravityY as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                accelerationIncludingGravityY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                accelerationIncludingGravityZ as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                accelerationIncludingGravityZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                rotationRateAlpha as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                rotationRateAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                rotationRateBeta as * const _ as usize } , 64usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                rotationRateBeta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenDeviceMotionEvent ) ) .
                rotationRateGamma as * const _ as usize } , 72usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EmscriptenDeviceMotionEvent ) , "::" , stringify ! (
                rotationRateGamma ) ));
}
impl Clone for EmscriptenDeviceMotionEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_devicemotion_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                deviceMotionEvent:
                                                    *const EmscriptenDeviceMotionEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_devicemotion_callback(userData:
                                                    *mut ::std::os::raw::c_void,
                                                useCapture:
                                                    ::std::os::raw::c_int,
                                                callback:
                                                    em_devicemotion_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_devicemotion_status(motionState:
                                                  *mut EmscriptenDeviceMotionEvent)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenOrientationChangeEvent {
    pub orientationIndex: ::std::os::raw::c_int,
    pub orientationAngle: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EmscriptenOrientationChangeEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenOrientationChangeEvent>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( EmscriptenOrientationChangeEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenOrientationChangeEvent>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EmscriptenOrientationChangeEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenOrientationChangeEvent ) ) .
                orientationIndex as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenOrientationChangeEvent ) , "::" , stringify ! (
                orientationIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenOrientationChangeEvent ) ) .
                orientationAngle as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenOrientationChangeEvent ) , "::" , stringify ! (
                orientationAngle ) ));
}
impl Clone for EmscriptenOrientationChangeEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_orientationchange_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                orientationChangeEvent:
                                                    *const EmscriptenOrientationChangeEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_orientationchange_callback(userData:
                                                         *mut ::std::os::raw::c_void,
                                                     useCapture:
                                                         ::std::os::raw::c_int,
                                                     callback:
                                                         em_orientationchange_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_orientation_status(orientationStatus:
                                                 *mut EmscriptenOrientationChangeEvent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_lock_orientation(allowedOrientations:
                                           ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_unlock_orientation() -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct EmscriptenFullscreenChangeEvent {
    pub isFullscreen: ::std::os::raw::c_int,
    pub fullscreenEnabled: ::std::os::raw::c_int,
    pub nodeName: [::std::os::raw::c_char; 128usize],
    pub id: [::std::os::raw::c_char; 128usize],
    pub elementWidth: ::std::os::raw::c_int,
    pub elementHeight: ::std::os::raw::c_int,
    pub screenWidth: ::std::os::raw::c_int,
    pub screenHeight: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EmscriptenFullscreenChangeEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenFullscreenChangeEvent>() ,
               280usize , concat ! (
               "Size of: " , stringify ! ( EmscriptenFullscreenChangeEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenFullscreenChangeEvent>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EmscriptenFullscreenChangeEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) .
                isFullscreen as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! (
                isFullscreen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) .
                fullscreenEnabled as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! (
                fullscreenEnabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) .
                nodeName as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! (
                nodeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) . id
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! ( id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) .
                elementWidth as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! (
                elementWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) .
                elementHeight as * const _ as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! (
                elementHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) .
                screenWidth as * const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! (
                screenWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenChangeEvent ) ) .
                screenHeight as * const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenChangeEvent ) , "::" , stringify ! (
                screenHeight ) ));
}
pub type em_fullscreenchange_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                fullscreenChangeEvent:
                                                    *const EmscriptenFullscreenChangeEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_fullscreenchange_callback(target:
                                                        *const ::std::os::raw::c_char,
                                                    userData:
                                                        *mut ::std::os::raw::c_void,
                                                    useCapture:
                                                        ::std::os::raw::c_int,
                                                    callback:
                                                        em_fullscreenchange_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_fullscreen_status(fullscreenStatus:
                                                *mut EmscriptenFullscreenChangeEvent)
     -> ::std::os::raw::c_int;
}
pub type em_canvasresized_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                reserved:
                                                    *const ::std::os::raw::c_void,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenFullscreenStrategy {
    pub scaleMode: ::std::os::raw::c_int,
    pub canvasResolutionScaleMode: ::std::os::raw::c_int,
    pub filteringMode: ::std::os::raw::c_int,
    pub canvasResizedCallback: em_canvasresized_callback_func,
    pub canvasResizedCallbackUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_EmscriptenFullscreenStrategy() {
    assert_eq!(::core::mem::size_of::<EmscriptenFullscreenStrategy>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( EmscriptenFullscreenStrategy ) ));
    assert_eq! (::core::mem::align_of::<EmscriptenFullscreenStrategy>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( EmscriptenFullscreenStrategy )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenStrategy ) ) .
                scaleMode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenStrategy ) , "::" , stringify ! (
                scaleMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenStrategy ) ) .
                canvasResolutionScaleMode as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenStrategy ) , "::" , stringify ! (
                canvasResolutionScaleMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenStrategy ) ) .
                filteringMode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenStrategy ) , "::" , stringify ! (
                filteringMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenStrategy ) ) .
                canvasResizedCallback as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenStrategy ) , "::" , stringify ! (
                canvasResizedCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenFullscreenStrategy ) ) .
                canvasResizedCallbackUserData as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenFullscreenStrategy ) , "::" , stringify ! (
                canvasResizedCallbackUserData ) ));
}
impl Clone for EmscriptenFullscreenStrategy {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn emscripten_request_fullscreen(target:
                                             *const ::std::os::raw::c_char,
                                         deferUntilInEventHandler:
                                             ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_request_fullscreen_strategy(target:
                                                      *const ::std::os::raw::c_char,
                                                  deferUntilInEventHandler:
                                                      ::std::os::raw::c_int,
                                                  fullscreenStrategy:
                                                      *const EmscriptenFullscreenStrategy)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_exit_fullscreen() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_enter_soft_fullscreen(target:
                                                *const ::std::os::raw::c_char,
                                            fullscreenStrategy:
                                                *const EmscriptenFullscreenStrategy)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_exit_soft_fullscreen() -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct EmscriptenPointerlockChangeEvent {
    pub isActive: ::std::os::raw::c_int,
    pub nodeName: [::std::os::raw::c_char; 128usize],
    pub id: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_EmscriptenPointerlockChangeEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenPointerlockChangeEvent>() ,
               260usize , concat ! (
               "Size of: " , stringify ! ( EmscriptenPointerlockChangeEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenPointerlockChangeEvent>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EmscriptenPointerlockChangeEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenPointerlockChangeEvent ) ) .
                isActive as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenPointerlockChangeEvent ) , "::" , stringify ! (
                isActive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenPointerlockChangeEvent ) ) .
                nodeName as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenPointerlockChangeEvent ) , "::" , stringify ! (
                nodeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenPointerlockChangeEvent ) ) . id
                as * const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenPointerlockChangeEvent ) , "::" , stringify ! ( id )
                ));
}
pub type em_pointerlockchange_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                pointerlockChangeEvent:
                                                    *const EmscriptenPointerlockChangeEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_pointerlockchange_callback(target:
                                                         *const ::std::os::raw::c_char,
                                                     userData:
                                                         *mut ::std::os::raw::c_void,
                                                     useCapture:
                                                         ::std::os::raw::c_int,
                                                     callback:
                                                         em_pointerlockchange_callback_func)
     -> ::std::os::raw::c_int;
}
pub type em_pointerlockerror_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                reserved:
                                                    *const ::std::os::raw::c_void,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_pointerlockerror_callback(target:
                                                        *const ::std::os::raw::c_char,
                                                    userData:
                                                        *mut ::std::os::raw::c_void,
                                                    useCapture:
                                                        ::std::os::raw::c_int,
                                                    callback:
                                                        em_pointerlockerror_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_pointerlock_status(pointerlockStatus:
                                                 *mut EmscriptenPointerlockChangeEvent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_request_pointerlock(target:
                                              *const ::std::os::raw::c_char,
                                          deferUntilInEventHandler:
                                              ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_exit_pointerlock() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenVisibilityChangeEvent {
    pub hidden: ::std::os::raw::c_int,
    pub visibilityState: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EmscriptenVisibilityChangeEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenVisibilityChangeEvent>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( EmscriptenVisibilityChangeEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenVisibilityChangeEvent>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EmscriptenVisibilityChangeEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenVisibilityChangeEvent ) ) .
                hidden as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenVisibilityChangeEvent ) , "::" , stringify ! (
                hidden ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenVisibilityChangeEvent ) ) .
                visibilityState as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenVisibilityChangeEvent ) , "::" , stringify ! (
                visibilityState ) ));
}
impl Clone for EmscriptenVisibilityChangeEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_visibilitychange_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                visibilityChangeEvent:
                                                    *const EmscriptenVisibilityChangeEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_visibilitychange_callback(userData:
                                                        *mut ::std::os::raw::c_void,
                                                    useCapture:
                                                        ::std::os::raw::c_int,
                                                    callback:
                                                        em_visibilitychange_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_visibility_status(visibilityStatus:
                                                *mut EmscriptenVisibilityChangeEvent)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenTouchPoint {
    pub identifier: ::std::os::raw::c_long,
    pub screenX: ::std::os::raw::c_long,
    pub screenY: ::std::os::raw::c_long,
    pub clientX: ::std::os::raw::c_long,
    pub clientY: ::std::os::raw::c_long,
    pub pageX: ::std::os::raw::c_long,
    pub pageY: ::std::os::raw::c_long,
    pub isChanged: ::std::os::raw::c_int,
    pub onTarget: ::std::os::raw::c_int,
    pub targetX: ::std::os::raw::c_long,
    pub targetY: ::std::os::raw::c_long,
    pub canvasX: ::std::os::raw::c_long,
    pub canvasY: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_EmscriptenTouchPoint() {
    assert_eq!(::core::mem::size_of::<EmscriptenTouchPoint>() , 96usize ,
               concat ! ( "Size of: " , stringify ! ( EmscriptenTouchPoint )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenTouchPoint>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenTouchPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . identifier as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( identifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . screenX as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( screenX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . screenY as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( screenY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . clientX as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( clientX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . clientY as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( clientY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . pageX as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( pageX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . pageY as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( pageY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . isChanged as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( isChanged ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . onTarget as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( onTarget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . targetX as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( targetX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . targetY as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( targetY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . canvasX as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( canvasX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchPoint ) ) . canvasY as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchPoint )
                , "::" , stringify ! ( canvasY ) ));
}
impl Clone for EmscriptenTouchPoint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenTouchEvent {
    pub numTouches: ::std::os::raw::c_int,
    pub ctrlKey: ::std::os::raw::c_int,
    pub shiftKey: ::std::os::raw::c_int,
    pub altKey: ::std::os::raw::c_int,
    pub metaKey: ::std::os::raw::c_int,
    pub touches: [EmscriptenTouchPoint; 32usize],
}
#[test]
fn bindgen_test_layout_EmscriptenTouchEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenTouchEvent>() , 3096usize ,
               concat ! ( "Size of: " , stringify ! ( EmscriptenTouchEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenTouchEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenTouchEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchEvent ) ) . numTouches as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchEvent )
                , "::" , stringify ! ( numTouches ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchEvent ) ) . ctrlKey as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchEvent )
                , "::" , stringify ! ( ctrlKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchEvent ) ) . shiftKey as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchEvent )
                , "::" , stringify ! ( shiftKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchEvent ) ) . altKey as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchEvent )
                , "::" , stringify ! ( altKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchEvent ) ) . metaKey as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchEvent )
                , "::" , stringify ! ( metaKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenTouchEvent ) ) . touches as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenTouchEvent )
                , "::" , stringify ! ( touches ) ));
}
impl Clone for EmscriptenTouchEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_touch_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                touchEvent:
                                                    *const EmscriptenTouchEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_touchstart_callback(target:
                                                  *const ::std::os::raw::c_char,
                                              userData:
                                                  *mut ::std::os::raw::c_void,
                                              useCapture:
                                                  ::std::os::raw::c_int,
                                              callback:
                                                  em_touch_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_touchend_callback(target:
                                                *const ::std::os::raw::c_char,
                                            userData:
                                                *mut ::std::os::raw::c_void,
                                            useCapture: ::std::os::raw::c_int,
                                            callback: em_touch_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_touchmove_callback(target:
                                                 *const ::std::os::raw::c_char,
                                             userData:
                                                 *mut ::std::os::raw::c_void,
                                             useCapture:
                                                 ::std::os::raw::c_int,
                                             callback: em_touch_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_touchcancel_callback(target:
                                                   *const ::std::os::raw::c_char,
                                               userData:
                                                   *mut ::std::os::raw::c_void,
                                               useCapture:
                                                   ::std::os::raw::c_int,
                                               callback:
                                                   em_touch_callback_func)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct EmscriptenGamepadEvent {
    pub timestamp: f64,
    pub numAxes: ::std::os::raw::c_int,
    pub numButtons: ::std::os::raw::c_int,
    pub axis: [f64; 64usize],
    pub analogButton: [f64; 64usize],
    pub digitalButton: [::std::os::raw::c_int; 64usize],
    pub connected: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_long,
    pub id: [::std::os::raw::c_char; 64usize],
    pub mapping: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_EmscriptenGamepadEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenGamepadEvent>() , 1440usize ,
               concat ! ( "Size of: " , stringify ! ( EmscriptenGamepadEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenGamepadEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenGamepadEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . timestamp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . numAxes as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( numAxes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . numButtons
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( numButtons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . axis as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( axis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . analogButton
                as * const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( analogButton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) .
                digitalButton as * const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( digitalButton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . connected as
                * const _ as usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( connected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . index as *
                const _ as usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . id as *
                const _ as usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenGamepadEvent ) ) . mapping as *
                const _ as usize } , 1376usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenGamepadEvent
                ) , "::" , stringify ! ( mapping ) ));
}
pub type em_gamepad_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                gamepadEvent:
                                                    *const EmscriptenGamepadEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_gamepadconnected_callback(userData:
                                                        *mut ::std::os::raw::c_void,
                                                    useCapture:
                                                        ::std::os::raw::c_int,
                                                    callback:
                                                        em_gamepad_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_gamepaddisconnected_callback(userData:
                                                           *mut ::std::os::raw::c_void,
                                                       useCapture:
                                                           ::std::os::raw::c_int,
                                                       callback:
                                                           em_gamepad_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_num_gamepads() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_gamepad_status(index: ::std::os::raw::c_int,
                                         gamepadState:
                                             *mut EmscriptenGamepadEvent)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenBatteryEvent {
    pub chargingTime: f64,
    pub dischargingTime: f64,
    pub level: f64,
    pub charging: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EmscriptenBatteryEvent() {
    assert_eq!(::core::mem::size_of::<EmscriptenBatteryEvent>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( EmscriptenBatteryEvent )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenBatteryEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( EmscriptenBatteryEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenBatteryEvent ) ) . chargingTime
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenBatteryEvent
                ) , "::" , stringify ! ( chargingTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenBatteryEvent ) ) .
                dischargingTime as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenBatteryEvent
                ) , "::" , stringify ! ( dischargingTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenBatteryEvent ) ) . level as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenBatteryEvent
                ) , "::" , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenBatteryEvent ) ) . charging as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( EmscriptenBatteryEvent
                ) , "::" , stringify ! ( charging ) ));
}
impl Clone for EmscriptenBatteryEvent {
    fn clone(&self) -> Self { *self }
}
pub type em_battery_callback_func =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                batteryEvent:
                                                    *const EmscriptenBatteryEvent,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_batterychargingchange_callback(userData:
                                                             *mut ::std::os::raw::c_void,
                                                         callback:
                                                             em_battery_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_batterylevelchange_callback(userData:
                                                          *mut ::std::os::raw::c_void,
                                                      callback:
                                                          em_battery_callback_func)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_battery_status(batteryState:
                                             *mut EmscriptenBatteryEvent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vibrate(msecs: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vibrate_pattern(msecsArray: *mut ::std::os::raw::c_int,
                                      numEntries: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type em_beforeunload_callback =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                reserved:
                                                    *const ::std::os::raw::c_void,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> *const ::std::os::raw::c_char>;
extern "C" {
    pub fn emscripten_set_beforeunload_callback(userData:
                                                    *mut ::std::os::raw::c_void,
                                                callback:
                                                    em_beforeunload_callback)
     -> ::std::os::raw::c_int;
}
pub type EMSCRIPTEN_WEBGL_CONTEXT_HANDLE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EmscriptenWebGLContextAttributes {
    pub alpha: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub stencil: ::std::os::raw::c_int,
    pub antialias: ::std::os::raw::c_int,
    pub premultipliedAlpha: ::std::os::raw::c_int,
    pub preserveDrawingBuffer: ::std::os::raw::c_int,
    pub preferLowPowerToHighPerformance: ::std::os::raw::c_int,
    pub failIfMajorPerformanceCaveat: ::std::os::raw::c_int,
    pub majorVersion: ::std::os::raw::c_int,
    pub minorVersion: ::std::os::raw::c_int,
    pub enableExtensionsByDefault: ::std::os::raw::c_int,
    pub explicitSwapControl: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EmscriptenWebGLContextAttributes() {
    assert_eq!(::core::mem::size_of::<EmscriptenWebGLContextAttributes>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( EmscriptenWebGLContextAttributes )
               ));
    assert_eq! (::core::mem::align_of::<EmscriptenWebGLContextAttributes>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                EmscriptenWebGLContextAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                alpha as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                alpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                depth as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                stencil as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                stencil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                antialias as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                antialias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                premultipliedAlpha as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                premultipliedAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                preserveDrawingBuffer as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                preserveDrawingBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                preferLowPowerToHighPerformance as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                preferLowPowerToHighPerformance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                failIfMajorPerformanceCaveat as * const _ as usize } , 28usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                failIfMajorPerformanceCaveat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                majorVersion as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                majorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                minorVersion as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                minorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                enableExtensionsByDefault as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                enableExtensionsByDefault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const EmscriptenWebGLContextAttributes ) ) .
                explicitSwapControl as * const _ as usize } , 44usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                EmscriptenWebGLContextAttributes ) , "::" , stringify ! (
                explicitSwapControl ) ));
}
impl Clone for EmscriptenWebGLContextAttributes {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn emscripten_webgl_init_context_attributes(attributes:
                                                        *mut EmscriptenWebGLContextAttributes);
}
extern "C" {
    pub fn emscripten_webgl_create_context(target:
                                               *const ::std::os::raw::c_char,
                                           attributes:
                                               *const EmscriptenWebGLContextAttributes)
     -> EMSCRIPTEN_WEBGL_CONTEXT_HANDLE;
}
extern "C" {
    pub fn emscripten_webgl_make_context_current(context:
                                                     EMSCRIPTEN_WEBGL_CONTEXT_HANDLE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_webgl_get_current_context()
     -> EMSCRIPTEN_WEBGL_CONTEXT_HANDLE;
}
extern "C" {
    pub fn emscripten_webgl_destroy_context(context:
                                                EMSCRIPTEN_WEBGL_CONTEXT_HANDLE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_webgl_enable_extension(context:
                                                 EMSCRIPTEN_WEBGL_CONTEXT_HANDLE,
                                             extension:
                                                 *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type em_webgl_context_callback =
    ::core::option::Option<unsafe extern "C" fn(eventType:
                                                    ::std::os::raw::c_int,
                                                reserved:
                                                    *const ::std::os::raw::c_void,
                                                userData:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_set_webglcontextlost_callback(target:
                                                        *const ::std::os::raw::c_char,
                                                    userData:
                                                        *mut ::std::os::raw::c_void,
                                                    useCapture:
                                                        ::std::os::raw::c_int,
                                                    callback:
                                                        em_webgl_context_callback)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_webglcontextrestored_callback(target:
                                                            *const ::std::os::raw::c_char,
                                                        userData:
                                                            *mut ::std::os::raw::c_void,
                                                        useCapture:
                                                            ::std::os::raw::c_int,
                                                        callback:
                                                            em_webgl_context_callback)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_is_webgl_context_lost(target:
                                                *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_webgl_commit_frame() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_element_css_size(target:
                                               *const ::std::os::raw::c_char,
                                           width: f64, height: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_get_element_css_size(target:
                                               *const ::std::os::raw::c_char,
                                           width: *mut f64, height: *mut f64)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct emscripten_fetch_t {
    pub id: ::std::os::raw::c_uint,
    pub userData: *mut ::std::os::raw::c_void,
    pub url: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_char,
    pub numBytes: u64,
    pub dataOffset: u64,
    pub totalBytes: u64,
    pub readyState: ::std::os::raw::c_ushort,
    pub status: ::std::os::raw::c_ushort,
    pub statusText: [::std::os::raw::c_char; 64usize],
    pub __proxyState: u32,
    pub __attributes: emscripten_fetch_attr_t,
}
#[test]
fn bindgen_test_layout_emscripten_fetch_t() {
    assert_eq!(::core::mem::size_of::<emscripten_fetch_t>() , 272usize ,
               concat ! ( "Size of: " , stringify ! ( emscripten_fetch_t ) ));
    assert_eq! (::core::mem::align_of::<emscripten_fetch_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( emscripten_fetch_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . userData as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( userData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . url as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( url ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . data as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . numBytes as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( numBytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . dataOffset as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( dataOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . totalBytes as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( totalBytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . readyState as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( readyState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . status as *
                const _ as usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . statusText as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( statusText ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . __proxyState as
                * const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( __proxyState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_t ) ) . __attributes as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_t ) ,
                "::" , stringify ! ( __attributes ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct emscripten_fetch_attr_t {
    pub requestMethod: [::std::os::raw::c_char; 32usize],
    pub userData: *mut ::std::os::raw::c_void,
    pub onsuccess: ::core::option::Option<unsafe extern "C" fn(fetch:
                                                                   *mut emscripten_fetch_t)>,
    pub onerror: ::core::option::Option<unsafe extern "C" fn(fetch:
                                                                 *mut emscripten_fetch_t)>,
    pub onprogress: ::core::option::Option<unsafe extern "C" fn(fetch:
                                                                    *mut emscripten_fetch_t)>,
    pub attributes: u32,
    pub timeoutMSecs: ::std::os::raw::c_ulong,
    pub withCredentials: ::std::os::raw::c_int,
    pub destinationPath: *const ::std::os::raw::c_char,
    pub userName: *const ::std::os::raw::c_char,
    pub password: *const ::std::os::raw::c_char,
    pub requestHeaders: *const *const ::std::os::raw::c_char,
    pub overriddenMimeType: *const ::std::os::raw::c_char,
    pub requestData: *const ::std::os::raw::c_char,
    pub requestDataSize: usize,
}
#[test]
fn bindgen_test_layout_emscripten_fetch_attr_t() {
    assert_eq!(::core::mem::size_of::<emscripten_fetch_attr_t>() , 144usize ,
               concat ! (
               "Size of: " , stringify ! ( emscripten_fetch_attr_t ) ));
    assert_eq! (::core::mem::align_of::<emscripten_fetch_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( emscripten_fetch_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) .
                requestMethod as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( requestMethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . userData as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( userData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . onsuccess
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( onsuccess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . onerror as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( onerror ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . onprogress
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( onprogress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . attributes
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) .
                timeoutMSecs as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( timeoutMSecs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) .
                withCredentials as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( withCredentials ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) .
                destinationPath as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( destinationPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . userName as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( userName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . password as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( password ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) .
                requestHeaders as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( requestHeaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) .
                overriddenMimeType as * const _ as usize } , 120usize , concat
                ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( overriddenMimeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) . requestData
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( requestData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const emscripten_fetch_attr_t ) ) .
                requestDataSize as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! ( emscripten_fetch_attr_t
                ) , "::" , stringify ! ( requestDataSize ) ));
}
impl Clone for emscripten_fetch_attr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn emscripten_fetch_attr_init(fetch_attr:
                                          *mut emscripten_fetch_attr_t);
}
extern "C" {
    pub fn emscripten_fetch(fetch_attr: *mut emscripten_fetch_attr_t,
                            url: *const ::std::os::raw::c_char)
     -> *mut emscripten_fetch_t;
}
extern "C" {
    pub fn emscripten_fetch_wait(fetch: *mut emscripten_fetch_t,
                                 timeoutMSecs: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_fetch_close(fetch: *mut emscripten_fetch_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __u: pthread_attr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t__bindgen_ty_1 {
    pub __i: __BindgenUnionField<[::std::os::raw::c_int; 11usize]>,
    pub __vi: __BindgenUnionField<[::std::os::raw::c_int; 11usize]>,
    pub __s: __BindgenUnionField<[::std::os::raw::c_uint; 11usize]>,
    pub bindgen_union_field: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pthread_attr_t__bindgen_ty_1>() ,
               44usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pthread_attr_t__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t__bindgen_ty_1 ) ) . __i as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_attr_t__bindgen_ty_1 ) , "::" , stringify ! ( __i )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t__bindgen_ty_1 ) ) . __vi
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_attr_t__bindgen_ty_1 ) , "::" , stringify ! ( __vi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t__bindgen_ty_1 ) ) . __s as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_attr_t__bindgen_ty_1 ) , "::" , stringify ! ( __s )
                ));
}
impl Clone for pthread_attr_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::core::mem::size_of::<pthread_attr_t>() , 44usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::core::mem::align_of::<pthread_attr_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __u as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __u ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn emscripten_has_threading_support() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_num_logical_cores() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_force_num_logical_cores(cores: ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_atomic_exchange_u8(addr: *mut ::std::os::raw::c_void,
                                         newVal: u8) -> u8;
}
extern "C" {
    pub fn emscripten_atomic_exchange_u16(addr: *mut ::std::os::raw::c_void,
                                          newVal: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_exchange_u32(addr: *mut ::std::os::raw::c_void,
                                          newVal: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_exchange_u64(addr: *mut ::std::os::raw::c_void,
                                          newVal: u64) -> u64;
}
extern "C" {
    pub fn emscripten_atomic_cas_u8(addr: *mut ::std::os::raw::c_void,
                                    oldVal: u8, newVal: u8) -> u8;
}
extern "C" {
    pub fn emscripten_atomic_cas_u16(addr: *mut ::std::os::raw::c_void,
                                     oldVal: u16, newVal: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_cas_u32(addr: *mut ::std::os::raw::c_void,
                                     oldVal: u32, newVal: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_cas_u64(addr: *mut ::std::os::raw::c_void,
                                     oldVal: u64, newVal: u64) -> u64;
}
extern "C" {
    pub fn emscripten_atomic_load_u8(addr: *const ::std::os::raw::c_void)
     -> u8;
}
extern "C" {
    pub fn emscripten_atomic_load_u16(addr: *const ::std::os::raw::c_void)
     -> u16;
}
extern "C" {
    pub fn emscripten_atomic_load_u32(addr: *const ::std::os::raw::c_void)
     -> u32;
}
extern "C" {
    pub fn emscripten_atomic_load_f32(addr: *const ::std::os::raw::c_void)
     -> f32;
}
extern "C" {
    pub fn emscripten_atomic_load_u64(addr: *const ::std::os::raw::c_void)
     -> u64;
}
extern "C" {
    pub fn emscripten_atomic_load_f64(addr: *const ::std::os::raw::c_void)
     -> f64;
}
extern "C" {
    pub fn emscripten_atomic_store_u8(addr: *mut ::std::os::raw::c_void,
                                      val: u8) -> u8;
}
extern "C" {
    pub fn emscripten_atomic_store_u16(addr: *mut ::std::os::raw::c_void,
                                       val: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_store_u32(addr: *mut ::std::os::raw::c_void,
                                       val: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_store_f32(addr: *mut ::std::os::raw::c_void,
                                       val: f32) -> f32;
}
extern "C" {
    pub fn emscripten_atomic_store_u64(addr: *mut ::std::os::raw::c_void,
                                       val: u64) -> u64;
}
extern "C" {
    pub fn emscripten_atomic_store_f64(addr: *mut ::std::os::raw::c_void,
                                       val: f64) -> f64;
}
extern "C" {
    pub fn emscripten_atomic_fence();
}
extern "C" {
    pub fn emscripten_atomic_add_u8(addr: *mut ::std::os::raw::c_void,
                                    val: u8) -> u8;
}
extern "C" {
    pub fn emscripten_atomic_add_u16(addr: *mut ::std::os::raw::c_void,
                                     val: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_add_u32(addr: *mut ::std::os::raw::c_void,
                                     val: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_add_u64(addr: *mut ::std::os::raw::c_void,
                                     val: u64) -> u64;
}
extern "C" {
    pub fn emscripten_atomic_sub_u8(addr: *mut ::std::os::raw::c_void,
                                    val: u8) -> u8;
}
extern "C" {
    pub fn emscripten_atomic_sub_u16(addr: *mut ::std::os::raw::c_void,
                                     val: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_sub_u32(addr: *mut ::std::os::raw::c_void,
                                     val: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_sub_u64(addr: *mut ::std::os::raw::c_void,
                                     val: u64) -> u64;
}
extern "C" {
    pub fn emscripten_atomic_and_u8(addr: *mut ::std::os::raw::c_void,
                                    val: u8) -> u8;
}
extern "C" {
    pub fn emscripten_atomic_and_u16(addr: *mut ::std::os::raw::c_void,
                                     val: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_and_u32(addr: *mut ::std::os::raw::c_void,
                                     val: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_and_u64(addr: *mut ::std::os::raw::c_void,
                                     val: u64) -> u64;
}
extern "C" {
    pub fn emscripten_atomic_or_u8(addr: *mut ::std::os::raw::c_void, val: u8)
     -> u8;
}
extern "C" {
    pub fn emscripten_atomic_or_u16(addr: *mut ::std::os::raw::c_void,
                                    val: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_or_u32(addr: *mut ::std::os::raw::c_void,
                                    val: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_or_u64(addr: *mut ::std::os::raw::c_void,
                                    val: u64) -> u64;
}
extern "C" {
    pub fn emscripten_atomic_xor_u8(addr: *mut ::std::os::raw::c_void,
                                    val: u8) -> u8;
}
extern "C" {
    pub fn emscripten_atomic_xor_u16(addr: *mut ::std::os::raw::c_void,
                                     val: u16) -> u16;
}
extern "C" {
    pub fn emscripten_atomic_xor_u32(addr: *mut ::std::os::raw::c_void,
                                     val: u32) -> u32;
}
extern "C" {
    pub fn emscripten_atomic_xor_u64(addr: *mut ::std::os::raw::c_void,
                                     val: u64) -> u64;
}
extern "C" {
    pub fn emscripten_futex_wait(addr: *mut ::std::os::raw::c_void, val: u32,
                                 maxWaitMilliseconds: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_futex_wake(addr: *mut ::std::os::raw::c_void,
                                 count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_futex_wake_or_requeue(addr: *mut ::std::os::raw::c_void,
                                            count: ::std::os::raw::c_int,
                                            addr2:
                                                *mut ::std::os::raw::c_void,
                                            cmpValue: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct em_variant_val {
    pub i: __BindgenUnionField<::std::os::raw::c_int>,
    pub f: __BindgenUnionField<f32>,
    pub d: __BindgenUnionField<f64>,
    pub vp: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub cp: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_em_variant_val() {
    assert_eq!(::core::mem::size_of::<em_variant_val>() , 8usize , concat ! (
               "Size of: " , stringify ! ( em_variant_val ) ));
    assert_eq! (::core::mem::align_of::<em_variant_val>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( em_variant_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_variant_val ) ) . i as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_variant_val ) , "::"
                , stringify ! ( i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_variant_val ) ) . f as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_variant_val ) , "::"
                , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_variant_val ) ) . d as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_variant_val ) , "::"
                , stringify ! ( d ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_variant_val ) ) . vp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_variant_val ) , "::"
                , stringify ! ( vp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_variant_val ) ) . cp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_variant_val ) , "::"
                , stringify ! ( cp ) ));
}
impl Clone for em_variant_val {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct em_queued_call {
    pub functionEnum: ::std::os::raw::c_int,
    pub functionPtr: *mut ::std::os::raw::c_void,
    pub operationDone: ::std::os::raw::c_int,
    pub args: [em_variant_val; 8usize],
    pub returnValue: em_variant_val,
    pub calleeDelete: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_em_queued_call() {
    assert_eq!(::core::mem::size_of::<em_queued_call>() , 104usize , concat !
               ( "Size of: " , stringify ! ( em_queued_call ) ));
    assert_eq! (::core::mem::align_of::<em_queued_call>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( em_queued_call ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_queued_call ) ) . functionEnum as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_queued_call ) , "::"
                , stringify ! ( functionEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_queued_call ) ) . functionPtr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( em_queued_call ) , "::"
                , stringify ! ( functionPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_queued_call ) ) . operationDone as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( em_queued_call ) , "::"
                , stringify ! ( operationDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_queued_call ) ) . args as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( em_queued_call ) , "::"
                , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_queued_call ) ) . returnValue as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( em_queued_call ) , "::"
                , stringify ! ( returnValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_queued_call ) ) . calleeDelete as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( em_queued_call ) , "::"
                , stringify ! ( calleeDelete ) ));
}
impl Clone for em_queued_call {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn emscripten_sync_run_in_main_thread(call: *mut em_queued_call);
}
extern "C" {
    pub fn emscripten_sync_run_in_main_thread_0(function:
                                                    ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn emscripten_sync_run_in_main_thread_1(function:
                                                    ::std::os::raw::c_int,
                                                arg1:
                                                    *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn emscripten_sync_run_in_main_thread_2(function:
                                                    ::std::os::raw::c_int,
                                                arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2:
                                                    *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn emscripten_sync_run_in_main_thread_3(function:
                                                    ::std::os::raw::c_int,
                                                arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3:
                                                    *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn emscripten_sync_run_in_main_thread_7(function:
                                                    ::std::os::raw::c_int,
                                                arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2:
                                                    *mut ::std::os::raw::c_void,
                                                arg3:
                                                    *mut ::std::os::raw::c_void,
                                                arg4:
                                                    *mut ::std::os::raw::c_void,
                                                arg5:
                                                    *mut ::std::os::raw::c_void,
                                                arg6:
                                                    *mut ::std::os::raw::c_void,
                                                arg7:
                                                    *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
pub type em_func_v = ::core::option::Option<unsafe extern "C" fn()>;
pub type em_func_vi =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type em_func_vii =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int,
                                                arg2: ::std::os::raw::c_int)>;
pub type em_func_viii =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int,
                                                arg2: ::std::os::raw::c_int,
                                                arg3: ::std::os::raw::c_int)>;
pub type em_func_i =
    ::core::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type em_func_ii =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)
                               -> ::std::os::raw::c_int>;
pub type em_func_iii =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int,
                                                arg2: ::std::os::raw::c_int)
                               -> ::std::os::raw::c_int>;
pub type em_func_iiii =
    ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int,
                                                arg2: ::std::os::raw::c_int,
                                                arg3: ::std::os::raw::c_int)
                               -> ::std::os::raw::c_int>;
extern "C" {
    pub fn emscripten_sync_run_in_main_runtime_thread_(sig:
                                                           ::std::os::raw::c_int,
                                                       func_ptr:
                                                           *mut ::std::os::raw::c_void, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_async_run_in_main_runtime_thread_(sig:
                                                            ::std::os::raw::c_int,
                                                        func_ptr:
                                                            *mut ::std::os::raw::c_void, ...);
}
extern "C" {
    pub fn emscripten_async_waitable_run_in_main_runtime_thread_(sig:
                                                                     ::std::os::raw::c_int,
                                                                 func_ptr:
                                                                     *mut ::std::os::raw::c_void, ...)
     -> *mut em_queued_call;
}
extern "C" {
    pub fn emscripten_wait_for_call_v(call: *mut em_queued_call,
                                      timeoutMSecs: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_wait_for_call_i(call: *mut em_queued_call,
                                      timeoutMSecs: f64,
                                      outResult: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_async_waitable_close(call: *mut em_queued_call);
}
extern "C" {
    pub fn emscripten_is_main_runtime_thread() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_is_main_browser_thread() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_main_thread_process_queued_calls();
}
extern "C" {
    pub fn emscripten_syscall(arg1: ::std::os::raw::c_int,
                              arg2: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_set_current_thread_status(newStatus:
                                                    ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_conditional_set_current_thread_status(expectedStatus:
                                                                ::std::os::raw::c_int,
                                                            newStatus:
                                                                ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_set_thread_name(threadId: pthread_t,
                                      name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn emscripten_pthread_attr_gettransferredcanvases(a:
                                                              *const pthread_attr_t,
                                                          str:
                                                              *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_pthread_attr_settransferredcanvases(a:
                                                              *mut pthread_attr_t,
                                                          str:
                                                              *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type float64x2 = [f64; 2usize];
pub type float32x4 = [f32; 4usize];
pub type int32x4 = [::std::os::raw::c_int; 4usize];
pub type uint32x4 = [::std::os::raw::c_uint; 4usize];
pub type int16x8 = [::std::os::raw::c_short; 8usize];
pub type uint16x8 = [::std::os::raw::c_ushort; 8usize];
pub type int8x16 = [::std::os::raw::c_char; 16usize];
pub type uint8x16 = [::std::os::raw::c_uchar; 16usize];
pub type bool64x2 = int32x4;
pub type bool32x4 = int32x4;
pub type bool16x8 = int16x8;
pub type bool8x16 = int8x16;
extern "C" {
    pub fn emscripten_float64x2_set(__s0: f64, __s1: f64) -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_splat(__s: f64) -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_max(__a: *mut f64, __b: *mut f64)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_min(__a: *mut f64, __b: *mut f64)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_maxNum(__a: *mut f64, __b: *mut f64)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_minNum(__a: *mut f64, __b: *mut f64)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_sqrt(__a: *mut f64) -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_reciprocalApproximation(__a: *mut f64)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_reciprocalSqrtApproximation(__a: *mut f64)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_abs(__a: *mut f64) -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_lessThan(__a: *mut f64, __b: *mut f64)
     -> bool64x2;
}
extern "C" {
    pub fn emscripten_float64x2_lessThanOrEqual(__a: *mut f64, __b: *mut f64)
     -> bool64x2;
}
extern "C" {
    pub fn emscripten_float64x2_greaterThan(__a: *mut f64, __b: *mut f64)
     -> bool64x2;
}
extern "C" {
    pub fn emscripten_float64x2_greaterThanOrEqual(__a: *mut f64,
                                                   __b: *mut f64) -> bool64x2;
}
extern "C" {
    pub fn emscripten_float64x2_equal(__a: *mut f64, __b: *mut f64)
     -> bool64x2;
}
extern "C" {
    pub fn emscripten_float64x2_notEqual(__a: *mut f64, __b: *mut f64)
     -> bool64x2;
}
extern "C" {
    pub fn emscripten_float64x2_select(__a: *mut ::std::os::raw::c_int,
                                       __b: *mut f64, __c: *mut f64)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_store(__p: *const ::std::os::raw::c_void,
                                      __a: *mut f64);
}
extern "C" {
    pub fn emscripten_float64x2_store1(__p: *const ::std::os::raw::c_void,
                                       __a: *mut f64);
}
extern "C" {
    pub fn emscripten_float64x2_load(__p: *const ::std::os::raw::c_void)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_load1(__p: *const ::std::os::raw::c_void)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_fromFloat32x4Bits(__a: *mut f32) -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_swizzle(__a: *mut f64,
                                        __lane0: ::std::os::raw::c_int,
                                        __lane1: ::std::os::raw::c_int)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float64x2_shuffle(__a: *mut f64, __b: *mut f64,
                                        __lane0: ::std::os::raw::c_int,
                                        __lane1: ::std::os::raw::c_int)
     -> float64x2;
}
extern "C" {
    pub fn emscripten_float32x4_set(__s0: f32, __s1: f32, __s2: f32,
                                    __s3: f32) -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_splat(__s: f32) -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_max(__a: *mut f32, __b: *mut f32)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_min(__a: *mut f32, __b: *mut f32)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_maxNum(__a: *mut f32, __b: *mut f32)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_minNum(__a: *mut f32, __b: *mut f32)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_sqrt(__a: *mut f32) -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_reciprocalApproximation(__a: *mut f32)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_reciprocalSqrtApproximation(__a: *mut f32)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_abs(__a: *mut f32) -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_select(__a: *mut ::std::os::raw::c_int,
                                       __b: *mut f32, __c: *mut f32)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_store(__p: *const ::std::os::raw::c_void,
                                      __a: *mut f32);
}
extern "C" {
    pub fn emscripten_float32x4_store1(__p: *const ::std::os::raw::c_void,
                                       __a: *mut f32);
}
extern "C" {
    pub fn emscripten_float32x4_store2(__p: *const ::std::os::raw::c_void,
                                       __a: *mut f32);
}
extern "C" {
    pub fn emscripten_float32x4_load(__p: *const ::std::os::raw::c_void)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_load1(__p: *const ::std::os::raw::c_void)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_load2(__p: *const ::std::os::raw::c_void)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_swizzle(__a: *mut f32,
                                        __lane0: ::std::os::raw::c_int,
                                        __lane1: ::std::os::raw::c_int,
                                        __lane2: ::std::os::raw::c_int,
                                        __lane3: ::std::os::raw::c_int)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_float32x4_shuffle(__a: *mut f32, __b: *mut f32,
                                        __lane0: ::std::os::raw::c_int,
                                        __lane1: ::std::os::raw::c_int,
                                        __lane2: ::std::os::raw::c_int,
                                        __lane3: ::std::os::raw::c_int)
     -> float32x4;
}
extern "C" {
    pub fn emscripten_int32x4_set(__s0: ::std::os::raw::c_int,
                                  __s1: ::std::os::raw::c_int,
                                  __s2: ::std::os::raw::c_int,
                                  __s3: ::std::os::raw::c_int) -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_splat(__s: ::std::os::raw::c_int) -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_select(__a: *mut ::std::os::raw::c_int,
                                     __b: *mut ::std::os::raw::c_int,
                                     __c: *mut ::std::os::raw::c_int)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_shiftLeftByScalar(__a:
                                                    *mut ::std::os::raw::c_int,
                                                __count:
                                                    ::std::os::raw::c_int)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_shiftRightByScalar(__a:
                                                     *mut ::std::os::raw::c_int,
                                                 __count:
                                                     ::std::os::raw::c_int)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_store(__p: *const ::std::os::raw::c_void,
                                    __a: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_int32x4_store1(__p: *const ::std::os::raw::c_void,
                                     __a: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_int32x4_store2(__p: *const ::std::os::raw::c_void,
                                     __a: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn emscripten_int32x4_load(__p: *const ::std::os::raw::c_void)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_load1(__p: *const ::std::os::raw::c_void)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_load2(__p: *const ::std::os::raw::c_void)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_fromFloat64x2(__a: *mut f64) -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_swizzle(__a: *mut ::std::os::raw::c_int,
                                      __lane0: ::std::os::raw::c_int,
                                      __lane1: ::std::os::raw::c_int,
                                      __lane2: ::std::os::raw::c_int,
                                      __lane3: ::std::os::raw::c_int)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_int32x4_shuffle(__a: *mut ::std::os::raw::c_int,
                                      __b: *mut ::std::os::raw::c_int,
                                      __lane0: ::std::os::raw::c_int,
                                      __lane1: ::std::os::raw::c_int,
                                      __lane2: ::std::os::raw::c_int,
                                      __lane3: ::std::os::raw::c_int)
     -> int32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_set(__s0: ::std::os::raw::c_uint,
                                   __s1: ::std::os::raw::c_uint,
                                   __s2: ::std::os::raw::c_uint,
                                   __s3: ::std::os::raw::c_uint) -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_splat(__s: ::std::os::raw::c_uint) -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_select(__a: *mut ::std::os::raw::c_uint,
                                      __b: *mut ::std::os::raw::c_uint,
                                      __c: *mut ::std::os::raw::c_uint)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_shiftLeftByScalar(__a:
                                                     *mut ::std::os::raw::c_uint,
                                                 __count:
                                                     ::std::os::raw::c_int)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_shiftRightByScalar(__a:
                                                      *mut ::std::os::raw::c_uint,
                                                  __count:
                                                      ::std::os::raw::c_int)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_store(__p: *const ::std::os::raw::c_void,
                                     __a: *mut ::std::os::raw::c_uint);
}
extern "C" {
    pub fn emscripten_uint32x4_store1(__p: *const ::std::os::raw::c_void,
                                      __a: *mut ::std::os::raw::c_uint);
}
extern "C" {
    pub fn emscripten_uint32x4_store2(__p: *const ::std::os::raw::c_void,
                                      __a: *mut ::std::os::raw::c_uint);
}
extern "C" {
    pub fn emscripten_uint32x4_load(__p: *const ::std::os::raw::c_void)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_load1(__p: *const ::std::os::raw::c_void)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_load2(__p: *const ::std::os::raw::c_void)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_fromFloat64x2(__a: *mut f64) -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_swizzle(__a: *mut ::std::os::raw::c_uint,
                                       __lane0: ::std::os::raw::c_int,
                                       __lane1: ::std::os::raw::c_int,
                                       __lane2: ::std::os::raw::c_int,
                                       __lane3: ::std::os::raw::c_int)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_uint32x4_shuffle(__a: *mut ::std::os::raw::c_uint,
                                       __b: *mut ::std::os::raw::c_uint,
                                       __lane0: ::std::os::raw::c_int,
                                       __lane1: ::std::os::raw::c_int,
                                       __lane2: ::std::os::raw::c_int,
                                       __lane3: ::std::os::raw::c_int)
     -> uint32x4;
}
extern "C" {
    pub fn emscripten_int16x8_set(__s0: ::std::os::raw::c_short,
                                  __s1: ::std::os::raw::c_short,
                                  __s2: ::std::os::raw::c_short,
                                  __s3: ::std::os::raw::c_short,
                                  __s4: ::std::os::raw::c_short,
                                  __s5: ::std::os::raw::c_short,
                                  __s6: ::std::os::raw::c_short,
                                  __s7: ::std::os::raw::c_short) -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_splat(__s: ::std::os::raw::c_short) -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_select(__a: *mut ::std::os::raw::c_short,
                                     __b: *mut ::std::os::raw::c_short,
                                     __c: *mut ::std::os::raw::c_short)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_addSaturate(__a: *mut ::std::os::raw::c_short,
                                          __b: *mut ::std::os::raw::c_short)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_subSaturate(__a: *mut ::std::os::raw::c_short,
                                          __b: *mut ::std::os::raw::c_short)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_shiftLeftByScalar(__a:
                                                    *mut ::std::os::raw::c_short,
                                                __count:
                                                    ::std::os::raw::c_int)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_shiftRightByScalar(__a:
                                                     *mut ::std::os::raw::c_short,
                                                 __count:
                                                     ::std::os::raw::c_int)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_store(__p: *const ::std::os::raw::c_void,
                                    __a: *mut ::std::os::raw::c_short);
}
extern "C" {
    pub fn emscripten_int16x8_load(__p: *const ::std::os::raw::c_void)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_swizzle(__a: *mut ::std::os::raw::c_short,
                                      __lane0: ::std::os::raw::c_int,
                                      __lane1: ::std::os::raw::c_int,
                                      __lane2: ::std::os::raw::c_int,
                                      __lane3: ::std::os::raw::c_int,
                                      __lane4: ::std::os::raw::c_int,
                                      __lane5: ::std::os::raw::c_int,
                                      __lane6: ::std::os::raw::c_int,
                                      __lane7: ::std::os::raw::c_int)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_int16x8_shuffle(__a: *mut ::std::os::raw::c_short,
                                      __b: *mut ::std::os::raw::c_short,
                                      __lane0: ::std::os::raw::c_int,
                                      __lane1: ::std::os::raw::c_int,
                                      __lane2: ::std::os::raw::c_int,
                                      __lane3: ::std::os::raw::c_int,
                                      __lane4: ::std::os::raw::c_int,
                                      __lane5: ::std::os::raw::c_int,
                                      __lane6: ::std::os::raw::c_int,
                                      __lane7: ::std::os::raw::c_int)
     -> int16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_set(__s0: ::std::os::raw::c_ushort,
                                   __s1: ::std::os::raw::c_ushort,
                                   __s2: ::std::os::raw::c_ushort,
                                   __s3: ::std::os::raw::c_ushort,
                                   __s4: ::std::os::raw::c_ushort,
                                   __s5: ::std::os::raw::c_ushort,
                                   __s6: ::std::os::raw::c_ushort,
                                   __s7: ::std::os::raw::c_ushort)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_splat(__s: ::std::os::raw::c_ushort)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_select(__a: *mut ::std::os::raw::c_short,
                                      __b: *mut ::std::os::raw::c_ushort,
                                      __c: *mut ::std::os::raw::c_ushort)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_addSaturate(__a: *mut ::std::os::raw::c_ushort,
                                           __b: *mut ::std::os::raw::c_ushort)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_subSaturate(__a: *mut ::std::os::raw::c_ushort,
                                           __b: *mut ::std::os::raw::c_ushort)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_shiftLeftByScalar(__a:
                                                     *mut ::std::os::raw::c_ushort,
                                                 __count:
                                                     ::std::os::raw::c_int)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_shiftRightByScalar(__a:
                                                      *mut ::std::os::raw::c_ushort,
                                                  __count:
                                                      ::std::os::raw::c_int)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_store(__p: *const ::std::os::raw::c_void,
                                     __a: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn emscripten_uint16x8_load(__p: *const ::std::os::raw::c_void)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_swizzle(__a: *mut ::std::os::raw::c_ushort,
                                       __lane0: ::std::os::raw::c_int,
                                       __lane1: ::std::os::raw::c_int,
                                       __lane2: ::std::os::raw::c_int,
                                       __lane3: ::std::os::raw::c_int,
                                       __lane4: ::std::os::raw::c_int,
                                       __lane5: ::std::os::raw::c_int,
                                       __lane6: ::std::os::raw::c_int,
                                       __lane7: ::std::os::raw::c_int)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_uint16x8_shuffle(__a: *mut ::std::os::raw::c_ushort,
                                       __b: *mut ::std::os::raw::c_ushort,
                                       __lane0: ::std::os::raw::c_int,
                                       __lane1: ::std::os::raw::c_int,
                                       __lane2: ::std::os::raw::c_int,
                                       __lane3: ::std::os::raw::c_int,
                                       __lane4: ::std::os::raw::c_int,
                                       __lane5: ::std::os::raw::c_int,
                                       __lane6: ::std::os::raw::c_int,
                                       __lane7: ::std::os::raw::c_int)
     -> uint16x8;
}
extern "C" {
    pub fn emscripten_int8x16_set(__s0: ::std::os::raw::c_char,
                                  __s1: ::std::os::raw::c_char,
                                  __s2: ::std::os::raw::c_char,
                                  __s3: ::std::os::raw::c_char,
                                  __s4: ::std::os::raw::c_char,
                                  __s5: ::std::os::raw::c_char,
                                  __s6: ::std::os::raw::c_char,
                                  __s7: ::std::os::raw::c_char,
                                  __s8: ::std::os::raw::c_char,
                                  __s9: ::std::os::raw::c_char,
                                  __s10: ::std::os::raw::c_char,
                                  __s11: ::std::os::raw::c_char,
                                  __s12: ::std::os::raw::c_char,
                                  __s13: ::std::os::raw::c_char,
                                  __s14: ::std::os::raw::c_char,
                                  __s15: ::std::os::raw::c_char) -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_splat(__s: ::std::os::raw::c_char) -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_select(__a: *mut ::std::os::raw::c_char,
                                     __b: *mut ::std::os::raw::c_char,
                                     __c: *mut ::std::os::raw::c_char)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_addSaturate(__a: *mut ::std::os::raw::c_char,
                                          __b: *mut ::std::os::raw::c_char)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_subSaturate(__a: *mut ::std::os::raw::c_char,
                                          __b: *mut ::std::os::raw::c_char)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_shiftLeftByScalar(__a:
                                                    *mut ::std::os::raw::c_char,
                                                __count:
                                                    ::std::os::raw::c_int)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_shiftRightByScalar(__a:
                                                     *mut ::std::os::raw::c_char,
                                                 __count:
                                                     ::std::os::raw::c_int)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_store(__p: *const ::std::os::raw::c_void,
                                    __a: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn emscripten_int8x16_load(__p: *const ::std::os::raw::c_void)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_swizzle(__a: *mut ::std::os::raw::c_char,
                                      __lane0: ::std::os::raw::c_int,
                                      __lane1: ::std::os::raw::c_int,
                                      __lane2: ::std::os::raw::c_int,
                                      __lane3: ::std::os::raw::c_int,
                                      __lane4: ::std::os::raw::c_int,
                                      __lane5: ::std::os::raw::c_int,
                                      __lane6: ::std::os::raw::c_int,
                                      __lane7: ::std::os::raw::c_int,
                                      __lane8: ::std::os::raw::c_int,
                                      __lane9: ::std::os::raw::c_int,
                                      __lane10: ::std::os::raw::c_int,
                                      __lane11: ::std::os::raw::c_int,
                                      __lane12: ::std::os::raw::c_int,
                                      __lane13: ::std::os::raw::c_int,
                                      __lane14: ::std::os::raw::c_int,
                                      __lane15: ::std::os::raw::c_int)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_int8x16_shuffle(__a: *mut ::std::os::raw::c_char,
                                      __b: *mut ::std::os::raw::c_char,
                                      __lane0: ::std::os::raw::c_int,
                                      __lane1: ::std::os::raw::c_int,
                                      __lane2: ::std::os::raw::c_int,
                                      __lane3: ::std::os::raw::c_int,
                                      __lane4: ::std::os::raw::c_int,
                                      __lane5: ::std::os::raw::c_int,
                                      __lane6: ::std::os::raw::c_int,
                                      __lane7: ::std::os::raw::c_int,
                                      __lane8: ::std::os::raw::c_int,
                                      __lane9: ::std::os::raw::c_int,
                                      __lane10: ::std::os::raw::c_int,
                                      __lane11: ::std::os::raw::c_int,
                                      __lane12: ::std::os::raw::c_int,
                                      __lane13: ::std::os::raw::c_int,
                                      __lane14: ::std::os::raw::c_int,
                                      __lane15: ::std::os::raw::c_int)
     -> int8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_set(__s0: ::std::os::raw::c_uchar,
                                   __s1: ::std::os::raw::c_uchar,
                                   __s2: ::std::os::raw::c_uchar,
                                   __s3: ::std::os::raw::c_uchar,
                                   __s4: ::std::os::raw::c_uchar,
                                   __s5: ::std::os::raw::c_uchar,
                                   __s6: ::std::os::raw::c_uchar,
                                   __s7: ::std::os::raw::c_uchar,
                                   __s8: ::std::os::raw::c_uchar,
                                   __s9: ::std::os::raw::c_uchar,
                                   __s10: ::std::os::raw::c_uchar,
                                   __s11: ::std::os::raw::c_uchar,
                                   __s12: ::std::os::raw::c_uchar,
                                   __s13: ::std::os::raw::c_uchar,
                                   __s14: ::std::os::raw::c_uchar,
                                   __s15: ::std::os::raw::c_uchar) -> int8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_splat(__s: ::std::os::raw::c_uchar) -> int8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_select(__a: *mut ::std::os::raw::c_char,
                                      __b: *mut ::std::os::raw::c_uchar,
                                      __c: *mut ::std::os::raw::c_uchar)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_addSaturate(__a: *mut ::std::os::raw::c_uchar,
                                           __b: *mut ::std::os::raw::c_uchar)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_subSaturate(__a: *mut ::std::os::raw::c_uchar,
                                           __b: *mut ::std::os::raw::c_uchar)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_shiftLeftByScalar(__a:
                                                     *mut ::std::os::raw::c_uchar,
                                                 __count:
                                                     ::std::os::raw::c_int)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_shiftRightByScalar(__a:
                                                      *mut ::std::os::raw::c_uchar,
                                                  __count:
                                                      ::std::os::raw::c_int)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_store(__p: *const ::std::os::raw::c_void,
                                     __a: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn emscripten_uint8x16_load(__p: *const ::std::os::raw::c_void)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_swizzle(__a: *mut ::std::os::raw::c_uchar,
                                       __lane0: ::std::os::raw::c_int,
                                       __lane1: ::std::os::raw::c_int,
                                       __lane2: ::std::os::raw::c_int,
                                       __lane3: ::std::os::raw::c_int,
                                       __lane4: ::std::os::raw::c_int,
                                       __lane5: ::std::os::raw::c_int,
                                       __lane6: ::std::os::raw::c_int,
                                       __lane7: ::std::os::raw::c_int,
                                       __lane8: ::std::os::raw::c_int,
                                       __lane9: ::std::os::raw::c_int,
                                       __lane10: ::std::os::raw::c_int,
                                       __lane11: ::std::os::raw::c_int,
                                       __lane12: ::std::os::raw::c_int,
                                       __lane13: ::std::os::raw::c_int,
                                       __lane14: ::std::os::raw::c_int,
                                       __lane15: ::std::os::raw::c_int)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_uint8x16_shuffle(__a: *mut ::std::os::raw::c_uchar,
                                       __b: *mut ::std::os::raw::c_uchar,
                                       __lane0: ::std::os::raw::c_int,
                                       __lane1: ::std::os::raw::c_int,
                                       __lane2: ::std::os::raw::c_int,
                                       __lane3: ::std::os::raw::c_int,
                                       __lane4: ::std::os::raw::c_int,
                                       __lane5: ::std::os::raw::c_int,
                                       __lane6: ::std::os::raw::c_int,
                                       __lane7: ::std::os::raw::c_int,
                                       __lane8: ::std::os::raw::c_int,
                                       __lane9: ::std::os::raw::c_int,
                                       __lane10: ::std::os::raw::c_int,
                                       __lane11: ::std::os::raw::c_int,
                                       __lane12: ::std::os::raw::c_int,
                                       __lane13: ::std::os::raw::c_int,
                                       __lane14: ::std::os::raw::c_int,
                                       __lane15: ::std::os::raw::c_int)
     -> uint8x16;
}
extern "C" {
    pub fn emscripten_bool64x2_anyTrue(__a: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_bool64x2_allTrue(__a: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_bool32x4_anyTrue(__a: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_bool32x4_allTrue(__a: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_bool16x8_anyTrue(__a: *mut ::std::os::raw::c_short)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_bool16x8_allTrue(__a: *mut ::std::os::raw::c_short)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_bool8x16_anyTrue(__a: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_bool8x16_allTrue(__a: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type WebVRDeviceId = i32;
pub type WebVRHardwareUnitId = i32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WebVREye { WebVREyeLeft = 0, WebVREyeRight = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WebVRDeviceType {
    WebVRUnknownDevice = 0,
    WebVRHMDDevice = 1,
    WebVRPositionSensorDevice = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebVRFieldOfView {
    pub upDegrees: f64,
    pub rightDegrees: f64,
    pub downDegrees: f64,
    pub leftDegrees: f64,
}
#[test]
fn bindgen_test_layout_WebVRFieldOfView() {
    assert_eq!(::core::mem::size_of::<WebVRFieldOfView>() , 32usize , concat !
               ( "Size of: " , stringify ! ( WebVRFieldOfView ) ));
    assert_eq! (::core::mem::align_of::<WebVRFieldOfView>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( WebVRFieldOfView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRFieldOfView ) ) . upDegrees as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRFieldOfView ) ,
                "::" , stringify ! ( upDegrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRFieldOfView ) ) . rightDegrees as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRFieldOfView ) ,
                "::" , stringify ! ( rightDegrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRFieldOfView ) ) . downDegrees as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRFieldOfView ) ,
                "::" , stringify ! ( downDegrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRFieldOfView ) ) . leftDegrees as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRFieldOfView ) ,
                "::" , stringify ! ( leftDegrees ) ));
}
impl Clone for WebVRFieldOfView {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebVRPoint {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_WebVRPoint() {
    assert_eq!(::core::mem::size_of::<WebVRPoint>() , 32usize , concat ! (
               "Size of: " , stringify ! ( WebVRPoint ) ));
    assert_eq! (::core::mem::align_of::<WebVRPoint>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WebVRPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPoint ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPoint ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPoint ) ) . y as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPoint ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPoint ) ) . z as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPoint ) , "::" ,
                stringify ! ( z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPoint ) ) . w as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPoint ) , "::" ,
                stringify ! ( w ) ));
}
impl Clone for WebVRPoint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebVRIntRect {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_WebVRIntRect() {
    assert_eq!(::core::mem::size_of::<WebVRIntRect>() , 16usize , concat ! (
               "Size of: " , stringify ! ( WebVRIntRect ) ));
    assert_eq! (::core::mem::align_of::<WebVRIntRect>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( WebVRIntRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRIntRect ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRIntRect ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRIntRect ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRIntRect ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRIntRect ) ) . width as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRIntRect ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRIntRect ) ) . height as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRIntRect ) , "::" ,
                stringify ! ( height ) ));
}
impl Clone for WebVRIntRect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebVRPositionState {
    pub timeStamp: f64,
    pub hasPosition: ::std::os::raw::c_int,
    pub position: WebVRPoint,
    pub linearVelocity: WebVRPoint,
    pub linearAcceleration: WebVRPoint,
    pub hasOrientation: ::std::os::raw::c_int,
    pub orientation: WebVRPoint,
    pub angularVelocity: WebVRPoint,
    pub angularAcceleration: WebVRPoint,
}
#[test]
fn bindgen_test_layout_WebVRPositionState() {
    assert_eq!(::core::mem::size_of::<WebVRPositionState>() , 216usize ,
               concat ! ( "Size of: " , stringify ! ( WebVRPositionState ) ));
    assert_eq! (::core::mem::align_of::<WebVRPositionState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( WebVRPositionState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) . timeStamp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( timeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) . hasPosition as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( hasPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) . position as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) . linearVelocity
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( linearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) .
                linearAcceleration as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( linearAcceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) . hasOrientation
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( hasOrientation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) . orientation as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( orientation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) . angularVelocity
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( angularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVRPositionState ) ) .
                angularAcceleration as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( WebVRPositionState ) ,
                "::" , stringify ! ( angularAcceleration ) ));
}
impl Clone for WebVRPositionState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebVREyeParameters {
    pub minimumFieldOfView: WebVRFieldOfView,
    pub maximumFieldOfView: WebVRFieldOfView,
    pub recommendedFieldOfView: WebVRFieldOfView,
    pub eyeTranslation: WebVRPoint,
    pub currentFieldOfView: WebVRFieldOfView,
    pub renderRect: WebVRIntRect,
}
#[test]
fn bindgen_test_layout_WebVREyeParameters() {
    assert_eq!(::core::mem::size_of::<WebVREyeParameters>() , 176usize ,
               concat ! ( "Size of: " , stringify ! ( WebVREyeParameters ) ));
    assert_eq! (::core::mem::align_of::<WebVREyeParameters>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( WebVREyeParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVREyeParameters ) ) .
                minimumFieldOfView as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( WebVREyeParameters ) ,
                "::" , stringify ! ( minimumFieldOfView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVREyeParameters ) ) .
                maximumFieldOfView as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( WebVREyeParameters ) ,
                "::" , stringify ! ( maximumFieldOfView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVREyeParameters ) ) .
                recommendedFieldOfView as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( WebVREyeParameters ) ,
                "::" , stringify ! ( recommendedFieldOfView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVREyeParameters ) ) . eyeTranslation
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVREyeParameters ) ,
                "::" , stringify ! ( eyeTranslation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVREyeParameters ) ) .
                currentFieldOfView as * const _ as usize } , 128usize , concat
                ! (
                "Alignment of field: " , stringify ! ( WebVREyeParameters ) ,
                "::" , stringify ! ( currentFieldOfView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebVREyeParameters ) ) . renderRect as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( WebVREyeParameters ) ,
                "::" , stringify ! ( renderRect ) ));
}
impl Clone for WebVREyeParameters {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn emscripten_vr_init();
}
extern "C" {
    pub fn emscripten_vr_ready() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vr_count_devices() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vr_get_device_id(deviceIndex: ::std::os::raw::c_int)
     -> WebVRDeviceId;
}
extern "C" {
    pub fn emscripten_vr_get_device_type(deviceId: WebVRDeviceId)
     -> WebVRDeviceType;
}
extern "C" {
    pub fn emscripten_vr_get_device_hwid(deviceId: WebVRDeviceId)
     -> WebVRHardwareUnitId;
}
extern "C" {
    pub fn emscripten_vr_get_device_name(deviceId: WebVRDeviceId)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn emscripten_vr_select_hmd_device(deviceId: WebVRDeviceId)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vr_get_selected_hmd_device() -> WebVRDeviceId;
}
extern "C" {
    pub fn emscripten_vr_hmd_get_eye_parameters(deviceId: WebVRDeviceId,
                                                whichEye: WebVREye,
                                                eyeParams:
                                                    *mut WebVREyeParameters)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vr_hmd_set_fov(deviceId: WebVRDeviceId,
                                     leftFov: *const WebVRFieldOfView,
                                     rightFov: *const WebVRFieldOfView,
                                     zNear: f64, zFar: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vr_sensor_get_state(deviceId: WebVRDeviceId,
                                          immediate: bool,
                                          state: *mut WebVRPositionState)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emscripten_vr_sensor_zero(deviceId: WebVRDeviceId)
     -> ::std::os::raw::c_int;
}
